# 2024-09-11

- 서버 사이드 렌더링

    생소할 수도 있지만 웹 페이지를 제공하는 가장 흔한 방법

    APM을 이용하는 일반적인 웹 페이지 생성이라고 보면 된다.

    여기에 자바스크립트 코드가 적재되면 동적으로 페이지 내용을 렌더링합니다.


    Next.js도 이와 같이 동적으로 페이지를 렌더링할 수 있다.
    그리고 여기에 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데 이를
    하이드레이션이라고 함.

    예를 들면 어떤 사람이 작성한 블로그 글을 한 페이지에 모아서 작성해야 한다면 SSR을 이용하는 것이 적당하다.

    서버 사이드 렌더링 -> 자바스크립트가 하이드레이션된 페이지를 전송 -> 클라이언트에서 DOM위에
    각 스크립트 코드를 하이드레이션 : 페이지 새로 고침 없이 사용자와 웹 페이지간 상호 작용 가능하게 함


    리액트 하이드레이션 덕분에 이 상태에서 웹 앱은 싱글 페이지 애플리케이션(SPA) 처럼 작동할 수 있다.

    SCR과 SSR의 장점을 모두 가지는 것

    특정 렌더링 전략만 사용한다고 가정하면 SSR이 CSR에 비해 여러 가지 장점이 있다.


SSR이 최적의 렌더링 전략이 아닌 경우

    클라이언트가 페이지를 요청할 때마다 페이지를 다시 렌더링할 수 있는 서버가 필요함

    다른 방식에 비해 SSR이 더 많은 자원을 소모하고, 더 많은 부하를 보이며 유지 보수 비용도 증가

    페이지에 대한 요청을 처리하는 시간이 길어짐

    페이지가 외부 API 또는 데이터 소스에 접근해야 한다면, 해당 페이지를 렌더링할 때마다 이를 다시 요청해야함.

    페이지 간의 이용은 CSR에 비해 느림


    중요한 것은 Next.js가 기본적으로 빌드 시점에 정적으로 페이지를 만든다는 것

    페이지에서 외부 API를 호출하거나 데이터베이스에 접근하는 등 동적 작업을 해야 한다면 해당하는 함수를 페이지에 export 해야함


CSR을 사용할 때의 주요 이점

    네이티브 앱처럼 느껴지는 웹 앱
        -전체 자바스크립트 번들을 다운로드 한다는 것은 렌더링할 모든 페이지가 이미 브라우저에 다운로드 되어 있다는 뜻입니다.
        -다른 페이지로 이동해도 서버에 요청할 필요 없이 바로 페이지를 이동할 수 있습니다.
        -페이지를 바꾸기 위해 새로 고칠 필요가 없습니다.

    쉬운 페이지 전환

        -클라이언트에서의 네비게이션은 브라우저 화면을 새로 고칠 필요 없이 다른 페이지로의 이동을 가능하게 만듭니다.
        -페이지 간 전환에 멋진 효과를 넣을 수도 있습니다. 애니메이션을 방해할 요소가 없기 떄문입니다.


process browser 변수

    서버에서 렌더링할 때 브라우저 전용 API로 인한 문제를 다른 방법으로 해결할 수도 있습니다.

    process browser 값에 따라서 스크립트와 컴포넌트를 조건별로 실행하는 것입니다.


정적 사이트 생성(SSG: Static Site Generation)

    SSG는 일부 또는 전체 페이지를 빌드 시점에 따라 렌더링 합니다.

    SSG는 SSR 및 CSR과 비교했을 때 다음과 같은 장점이 있다.

    1. 쉬운 확장
        정적 페이지는 단순 HTML 파일이므로 CDN을 통해 파일을 제공하거나 캐시에 저장하기 쉽다.

    2. 뛰어난 성능
        빌드 시점에 HTML 페이지를 미리 렌더링하기 때문에 페이지를 요청해도 클라이언트나 서버가 무언가를 처리할 필요가 없다.

    3. 더 안전한 API 요청
        외부 API를 호출하거나, 데이터베이스에 접근하거나, 보호해야 할 데이터에 접근할 일이 없다.
        필요한 모든 정보가 빌드 시점에 미리 페이지로 렌더링 되어 있기 때문이다.


    SSG는 높은 확장성과 뛰어난 성능을 보이는 프런트엔드 어플리케이션을 만들고 싶을 때 가장 좋은 방법

    한 가지 문제점은 웹 페이지를 만들고 나면 다음 베포 전까지 내용이 변하지 않는다는 점

    조금이라도 수정하려면 필요한 데이터를 가져와서 수정하고 다시 생성하는 과정 반복

    이런 문제 때문에 나온 방법이 바로 증분 정적 재생성(ISR: incremental static regenartaion) 이다.

    예를 들어 동적 콘텐츠를 제공하지만 해당 콘텐츠 데이터를 로딩 하는데 시간이 오래 걸린다면 SSG와 ISR을 함께 사용하여 문제를 해결할 수 있다.

    많은 양의 데이터를 필요로 하는 복잡한 대시보드를 만든다면 데이터를 불러 오기 위한 REST API 호출에 수 초가 소요된다.

    만일 데이터가 자주 변하지 않는다면 SSG와 ISR을 사용해서 데이터를 10분동안 캐싱할 수 있다.


    Page Project Layout - _app

        _app.jsx는 서버에 요청할 때 가장 먼저 실행되는 컴포넌트입니다.

        페이지에 적용할 공통 레이아웃을 선언하는 곳입니다



    
    Page Project Layout - _document

        _document.jsx는 app_jsx 다음에 실행됩니다.

        각 페이지에서 공통적으로 사용될 html, head, body 안에 들어갈 내용을 선언합니다.

        onClick 같은 이벤트나 CSS는 이 곳에 선언하지 않습니다.

        만일 로직이나 스타일이 필요하다면 _app.jsx에 선언해야 합니다.

        기본 코드는 다음과 같습니다

        ```js
        import [ Html, Head, Main, NextScript ]from "next/document";

        export default function Document() {
            return (
                <Html lang="en">
                <Head />
                <body>
                    <Main />
                    <NextScript />
                </body>
                </Html>
            );
        }
        ```


App Project Layout - RootLayout

    Children prop은 각각의 page.jsx를 받아 옵니다.

    
    Body에 header와 footer를 추가한 코드입니다.

    이때 children prop을 삭제하지 않도록 주의합니다.


    ```js
    export default function RootLayout{{ children }} {
        return (
            <html lang="ko">
            <body>
            <header></header>
            <main{children}></main>
            <footer></footer>
            </body>
        </html>
        )
    }
    ```

Image component - local

    WebP와 같은 최신 이미지 포맷 및 최신 포맷을 지원하지 않는 브라우저를 위해 png나 jpge와 같은 예전 이미지 포맷도 제공합니다.

    Pixabay나 Unplash와 같은 외부 이미지 서비스로 이미지를 제공할 수 있습니다.

